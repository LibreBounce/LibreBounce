/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.utils.block.BlockUtils.collideBlockIntersects
import net.ccbluex.liquidbounce.utils.block.block
import net.ccbluex.liquidbounce.utils.client.PacketUtils.sendPackets
import net.ccbluex.liquidbounce.utils.extensions.isMoving
import net.ccbluex.liquidbounce.utils.extensions.step
import net.ccbluex.liquidbounce.utils.extensions.component1
import net.ccbluex.liquidbounce.utils.extensions.component2
import net.ccbluex.liquidbounce.utils.extensions.component3
import net.ccbluex.liquidbounce.utils.movement.MovementUtils.direction
import net.ccbluex.liquidbounce.utils.timing.TickTimer
import net.minecraft.block.Block
import net.minecraft.init.Blocks.air
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import kotlin.math.cos
import kotlin.math.sin

object Phase : Module("Phase", Category.EXPLOIT) {

    private val mode by choices(
        "Mode",
        arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex", "FullBlock"),
        "Vanilla"
    )

    private val tickTimer = TickTimer()
    private var mineplexClip = false
    private val mineplexTickTimer = TickTimer()
    private var shouldContinue = false
    private var clipState = 0
    private var yaw = 0.0
    private var phaseValue = 0.0 // TODO: What is this???

    val onUpdate = handler<UpdateEvent> {
        val player = mc.thePlayer ?: return@handler
        val (x, y, z) = player

        if (mode == "FullBlock") {
            return@handler
        }

        val isInsideBlock = collideBlockIntersects(player.entityBoundingBox) { block: Block? -> block !== air }

        if (isInsideBlock && mode != "Mineplex") {
            player.noClip = true
            player.motionY = 0.0
            player.onGround = false
        }

        val shouldPhase = tickTimer.hasTimePassed(2) && player.isCollidedHorizontally && (!isInsideBlock || player.isSneaking)
        val shouldPhase2 = player.onGround && shouldPhase

        when (mode) {
            "Vanilla" -> {
                if (shouldPhase2) {
                    sendPackets(
                        C04PacketPlayerPosition(x, y, z, true),
                        C04PacketPlayerPosition(0.5, 0.0, 0.5, true),
                        C04PacketPlayerPosition(x, y, z, true),
                        C04PacketPlayerPosition(x, y + 0.2, z, true),
                        C04PacketPlayerPosition(0.5, 0.0, 0.5, true),
                        C04PacketPlayerPosition(
                            x + 0.5,
                            y,
                            z + 0.5,
                            true
                        )
                    )

                    val yaw = Math.toRadians(player.rotationYaw.toDouble())

                    player.setPosition(player.posX + -sin(yaw) * 0.04, player.posY, player.posZ + cos(yaw) * 0.04)
                    tickTimer.reset()
                }
            }

            "Skip" -> {
                if (shouldPhase2) {
                    val direction = direction
                    val posX = -sin(direction) * 0.3
                    val posZ = cos(direction) * 0.3

                    for (i in 0..2) {
                        sendPackets(
                            C04PacketPlayerPosition(
                                x,
                                y + 0.06,
                                z,
                                true
                            ),
                            C04PacketPlayerPosition(
                                x + posX * i,
                                y,
                                z + posZ * i,
                                true
                            )
                        )
                    }

                    player.entityBoundingBox = player.entityBoundingBox.offset(posX, 0.0, posZ)
                    player.setPositionAndUpdate(
                        x + posX,
                        y,
                        z + posZ
                    )
                    tickTimer.reset()
                }
            }

            "Spartan" -> {
                if (shouldPhase2) {
                    sendPackets(
                        C04PacketPlayerPosition(x, y, z, true),
                        C04PacketPlayerPosition(0.5, 0.0, 0.5, true),
                        C04PacketPlayerPosition(x, y, z, true),
                        C04PacketPlayerPosition(x, y - 0.2, z, true),
                        C04PacketPlayerPosition(0.5, 0.0, 0.5, true),
                        C04PacketPlayerPosition(
                            x + 0.5,
                            y,
                            z + 0.5,
                            true
                        )
                    )

                    val yaw = Math.toRadians(player.rotationYaw.toDouble())
                    val newX = -sin(yaw) * 0.04
                    val newZ = cos(yaw) * 0.04

                    player.setPosition(x + newX, y, z + newZ)
                    tickTimer.reset()
                }
            }

            "Clip" -> {
                if (shouldPhase) {
                    val yaw = Math.toRadians(player.rotationYaw.toDouble())

                    for (i in 1..10) {
                        val newX = -sin(yaw) * i
                        val newZ = cos(yaw) * i

                        if (BlockPos(x + newX, y, z + newZ).block === air && BlockPos(
                                x + newX,
                                y + 1,
                                z + newZ
                            ).block === air
                        ) {
                            player.setPosition(x + newX, y, z + newZ)
                            break
                        }
                    }
                    tickTimer.reset()
                }
            }

            "AAC3.5.0" -> {
                if (shouldPhase) {
                    val yaw = Math.toRadians(player.rotationYaw.toDouble())
                    val newX = -sin(yaw)
                    val newZ = cos(yaw)

                    player.setPosition(x + newX, y, z + newZ)
                    tickTimer.reset()
                }
            }
        }
        tickTimer.update()
    }

    val onBlockBB = handler<BlockBBEvent> { event ->
        if (mode == "FullBlock" || mode == "Mineplex") {
            return@handler
        }

        if (mc.thePlayer != null && collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block: Block? -> block !== air } && event.boundingBox != null && event.boundingBox!!.maxY > mc.thePlayer.entityBoundingBox.minY) {
            val axisAlignedBB = event.boundingBox

            event.boundingBox = AxisAlignedBB.fromBounds(
                axisAlignedBB!!.maxX,
                mc.thePlayer.entityBoundingBox.minY,
                axisAlignedBB.maxZ,
                axisAlignedBB.minX,
                axisAlignedBB.minY,
                axisAlignedBB.minZ
            )
        }
    }

    override fun onEnable() {
        shouldContinue = false
        clipState = 0
        phaseValue = 0.0
    }

    val onPacket = handler<PacketEvent> { event ->
        val packet = event.packet

        if (packet is C03PacketPlayer) {
            if (mode == "AAC3.5.0") {
                val yaw = direction.toFloat()

                packet.x -= sin(yaw.toDouble()) * 0.00000001
                packet.z += cos(yaw.toDouble()) * 0.00000001
            }
        }
    }

    val onMove = handler<MoveEvent> { event ->
        val player = mc.thePlayer ?: return@handler
        val (x, y, z) = player

        when (mode) {
            "Mineplex" -> {
                if (player.isCollidedHorizontally)
                    mineplexClip = true

                if (!mineplexClip)
                    return@handler

                mineplexTickTimer.update()

                event.x = 0.0
                event.z = 0.0

                if (mineplexTickTimer.hasTimePassed(3)) {
                    mineplexTickTimer.reset()
                    mineplexClip = false
                } else if (mineplexTickTimer.hasTimePassed(1)) {
                    val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                    val direction = direction

                    player.setPosition(
                        x + (-sin(direction) * offset),
                        y,
                        z + (cos(direction) * offset)
                    )
                }
            }

            "FullBlock" -> {
                if (player.isCollidedHorizontally)
                    clipState++

                when (clipState) {
                    1 -> {
                        val direction = direction
                        val cos = cos(direction)
                        val sin = sin(direction)

                        for (i in 0.025..2.0 step 0.025) {
                            shouldContinue = false
                            if (!player.isMoving || mc.theWorld.getCollidingBoundingBoxes(
                                    player,
                                    player.entityBoundingBox
                                        .offset(
                                            -sin * i,
                                            0.0,
                                            cos * i
                                        )
                                ).isNotEmpty()
                            ) continue

                            player.setPositionAndUpdate(
                                x - sin * 0.06,
                                y,
                                z + cos * 0.06
                            )

                            if (i > 0.06) {
                                phaseValue = i
                                yaw = direction
                                shouldContinue = true
                            }

                            event.zeroXZ()
                            break
                        }

                        clipState++
                        if (!shouldContinue)
                            clipState = 0
                    }

                    2 -> {
                        val value = if (player.isMoving) phaseValue else -0.06
                        player.setPositionAndUpdate(
                            x - (sin(yaw) * value),
                            y,
                            z + (cos(yaw) * value)
                        )
                        clipState = 0
                    }
                }
            }
        }
    }

    val onBlockPush = handler<BlockPushEvent> { event ->
        event.cancelEvent()
    }

    override val tag get() = mode
}